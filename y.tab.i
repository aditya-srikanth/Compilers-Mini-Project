# 1 "y.tab.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 365 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "y.tab.c" 2
# 11 "parser.y"

# 1 "./parser.h" 1



# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdbool.h" 1 3
# 5 "./parser.h" 2
# 1 "./headers.h" 1



# 1 "/data/data/com.termux/files/usr/include/stdio.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 1 3 4
# 40 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/api-level.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/android/api-level.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/android/api-level.h" 2 3 4
# 41 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/android/versioning.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/include/sys/cdefs.h" 2 3 4
# 42 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/types.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 51 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 62 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 90 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 118 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/__stddef_max_align_t.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/__stddef_max_align_t.h" 3 4
typedef struct {
  long long __clang_max_align_nonce1
      __attribute__((__aligned__(__alignof__(long long))));
  long double __clang_max_align_nonce2
      __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;
# 119 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdint.h" 1 3 4
# 63 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/stdint.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/stdint.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/wchar_limits.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/stdint.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/stdint.h" 2 3 4


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long __int64_t;
typedef unsigned long __uint64_t;






typedef long __intptr_t;
typedef unsigned long __uintptr_t;





typedef __int8_t int8_t;
typedef __uint8_t uint8_t;

typedef __int16_t int16_t;
typedef __uint16_t uint16_t;

typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;

typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;

typedef int8_t int_least8_t;
typedef uint8_t uint_least8_t;

typedef int16_t int_least16_t;
typedef uint16_t uint_least16_t;

typedef int32_t int_least32_t;
typedef uint32_t uint_least32_t;

typedef int64_t int_least64_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef uint8_t uint_fast8_t;

typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;


typedef int64_t int_fast16_t;
typedef uint64_t uint_fast16_t;
typedef int64_t int_fast32_t;
typedef uint64_t uint_fast32_t;







typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 64 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdint.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/linux/types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/types.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/asm/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/bitsperlong.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/asm/bitsperlong.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm/bitsperlong.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/asm-generic/int-ll64.h" 2 3 4

typedef __signed__ char __s8;
typedef unsigned char __u8;
typedef __signed__ short __s16;
typedef unsigned short __u16;
typedef __signed__ int __s32;
typedef unsigned int __u32;

__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 22 "/data/data/com.termux/files/usr/include/asm-generic/types.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/asm/types.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/types.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/stddef.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/linux/stddef.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/compiler_types.h" 1 3 4




# 1 "/data/data/com.termux/files/usr/include/linux/compiler.h" 1 3 4
# 6 "/data/data/com.termux/files/usr/include/linux/compiler_types.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/linux/stddef.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 2 3 4


typedef struct {
  unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;
typedef void(* __kernel_sighandler_t) (int);
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/data/data/com.termux/files/usr/include/asm/posix_types.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm/posix_types.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


# 1 "/data/data/com.termux/files/usr/include/asm-generic/posix_types.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;


typedef __kernel_ulong_t __kernel_ino_t;


typedef unsigned int __kernel_mode_t;


typedef int __kernel_pid_t;


typedef int __kernel_ipc_pid_t;


typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;


typedef __kernel_long_t __kernel_suseconds_t;


typedef int __kernel_daddr_t;


typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;






typedef unsigned int __kernel_old_dev_t;







typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;



typedef struct {
  int val[2];
} __kernel_fsid_t;

typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 25 "/data/data/com.termux/files/usr/include/asm/posix_types.h" 2 3 4
# 31 "/data/data/com.termux/files/usr/include/linux/posix_types.h" 2 3 4
# 24 "/data/data/com.termux/files/usr/include/linux/types.h" 2 3 4


typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;






typedef unsigned __poll_t;
# 37 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/types.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 2 3 4

typedef struct {
  uint32_t flags;
  void* stack_base;
  size_t stack_size;
  size_t guard_size;
  int32_t sched_policy;
  int32_t sched_priority;

  char __reserved[16];

} pthread_attr_t;
# 61 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
typedef struct {

  int32_t __private[12];



} pthread_cond_t;

typedef long pthread_condattr_t;

typedef int pthread_key_t;

typedef struct {

  int32_t __private[10];



} pthread_mutex_t;

typedef long pthread_mutexattr_t;

typedef int pthread_once_t;

typedef struct {

  int32_t __private[14];



} pthread_rwlock_t;

typedef long pthread_rwlockattr_t;
# 105 "/data/data/com.termux/files/usr/include/bits/pthread_types.h" 3 4
typedef long pthread_t;
# 40 "/data/data/com.termux/files/usr/include/sys/types.h" 2 3 4


typedef __kernel_gid32_t __gid_t;
typedef __gid_t gid_t;
typedef __kernel_uid32_t __uid_t;
typedef __uid_t uid_t;
typedef __kernel_pid_t __pid_t;
typedef __pid_t pid_t;
typedef uint32_t __id_t;
typedef __id_t id_t;

typedef unsigned long blkcnt_t;
typedef unsigned long blksize_t;
typedef __kernel_caddr_t caddr_t;
typedef __kernel_clock_t clock_t;

typedef __kernel_clockid_t __clockid_t;
typedef __clockid_t clockid_t;

typedef __kernel_daddr_t daddr_t;
typedef unsigned long fsblkcnt_t;
typedef unsigned long fsfilcnt_t;

typedef __kernel_mode_t __mode_t;
typedef __mode_t mode_t;

typedef __kernel_key_t __key_t;
typedef __key_t key_t;

typedef __kernel_ino_t __ino_t;
typedef __ino_t ino_t;

typedef uint64_t ino64_t;

typedef uint32_t __nlink_t;
typedef __nlink_t nlink_t;

typedef void* __timer_t;
typedef __timer_t timer_t;

typedef __kernel_suseconds_t __suseconds_t;
typedef __suseconds_t suseconds_t;


typedef uint32_t __useconds_t;
typedef __useconds_t useconds_t;





typedef uint64_t dev_t;



typedef __kernel_time_t __time_t;
typedef __time_t time_t;




typedef int64_t off_t;
typedef off_t loff_t;
typedef loff_t off64_t;
# 115 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
typedef uint32_t __socklen_t;

typedef __socklen_t socklen_t;

typedef __builtin_va_list __va_list;
# 128 "/data/data/com.termux/files/usr/include/sys/types.h" 3 4
typedef __kernel_ssize_t ssize_t;


typedef unsigned int uint_t;
typedef unsigned int uint;


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 43 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdarg.h" 1 3 4
# 30 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 45 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 46 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/string.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/string.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/string.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/xlocale.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/xlocale.h" 3 4
struct __locale_t;
typedef struct __locale_t* locale_t;
# 35 "/data/data/com.termux/files/usr/include/string.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/strcasecmp.h" 1 3 4
# 38 "/data/data/com.termux/files/usr/include/bits/strcasecmp.h" 3 4
int strcasecmp(const char* __s1, const char* __s2) __attribute__((__pure__));





int strncasecmp(const char* __s1, const char* __s2, size_t __n) __attribute__((__pure__));
# 37 "/data/data/com.termux/files/usr/include/string.h" 2 3 4







void* memccpy(void* __dst, const void* __src, int __stop_char, size_t __n);
void* memchr(const void* __s, int __ch, size_t __n) __attribute__((__pure__));




void* memrchr(const void* __s, int __ch, size_t __n) __attribute__((__pure__));

int memcmp(const void* __lhs, const void* __rhs, size_t __n) __attribute__((__pure__));
void* memcpy(void*, const void*, size_t);







void* memmove(void* __dst, const void* __src, size_t __n);
void* memset(void* __dst, int __ch, size_t __n);
void* memmem(const void* __haystack, size_t __haystack_size, const void* __needle, size_t __needle_size) __attribute__((__pure__));

char* strchr(const char* __s, int __ch) __attribute__((__pure__));


char* __strchr_chk(const char* __s, int __ch, size_t __n) __attribute__((annotate("introduced_in=" "18")));
# 88 "/data/data/com.termux/files/usr/include/string.h" 3 4
char* strrchr(const char* __s, int __ch) __attribute__((__pure__));


char* __strrchr_chk(const char* __s, int __ch, size_t __n) __attribute__((annotate("introduced_in=" "18")));



size_t strlen(const char* __s) __attribute__((__pure__));


size_t __strlen_chk(const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "17")));



int strcmp(const char* __lhs, const char* __rhs) __attribute__((__pure__));


char* stpcpy(char* __dst, const char* __src) __attribute__((annotate("introduced_in=" "21")));


char* strcpy(char* __dst, const char* __src);
char* strcat(char* __dst, const char* __src);
char* strdup(const char* __s);

char* strstr(const char* __haystack, const char* __needle) __attribute__((__pure__));




char* strcasestr(const char* __haystack, const char* __needle) __attribute__((__pure__));

char* strtok(char* __s, const char* __delimiter);
char* strtok_r(char* __s, const char* __delimiter, char** __pos_ptr);

char* strerror(int __errno_value);
# 131 "/data/data/com.termux/files/usr/include/string.h" 3 4
int strerror_r(int __errno_value, char* __buf, size_t __n);


size_t strnlen(const char* __s, size_t __n) __attribute__((__pure__));
char* strncat(char* __dst, const char* __src, size_t __n);
char* strndup(const char* __s, size_t __n);
int strncmp(const char* __lhs, const char* __rhs, size_t __n) __attribute__((__pure__));


char* stpncpy(char* __dst, const char* __src, size_t __n) __attribute__((annotate("introduced_in=" "21")));


char* strncpy(char* __dst, const char* __src, size_t __n);

size_t strlcat(char* __dst, const char* __src, size_t __n);
size_t strlcpy(char* __dst, const char* __src, size_t __n);

size_t strcspn(const char* __s, const char* __reject) __attribute__((__pure__));
char* strpbrk(const char* __s, const char* __accept) __attribute__((__pure__));
char* strsep(char** __s_ptr, const char* __delimiter);
size_t strspn(const char* __s, const char* __accept);

char* strsignal(int __signal);

int strcoll(const char* __lhs, const char* __rhs) __attribute__((__pure__));
size_t strxfrm(char* __dst, const char* __src, size_t __n);


int strcoll_l(const char* __lhs, const char* __rhs, locale_t __l) __attribute__((__pure__)) __attribute__((annotate("introduced_in=" "21")));
size_t strxfrm_l(char* __dst, const char* __src, size_t __n, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
# 48 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/fcntl.h" 1 3 4
# 25 "/data/data/com.termux/files/usr/include/asm/fcntl.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 1 3 4
# 121 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 3 4
struct f_owner_ex {
  int type;
  __kernel_pid_t pid;
};
# 148 "/data/data/com.termux/files/usr/include/asm-generic/fcntl.h" 3 4
struct flock {
  short l_type;
  short l_whence;
  __kernel_off_t l_start;
  __kernel_off_t l_len;
  __kernel_pid_t l_pid;

};





struct flock64 {
  short l_type;
  short l_whence;
  __kernel_loff_t l_start;
  __kernel_loff_t l_len;
  __kernel_pid_t l_pid;

};
# 26 "/data/data/com.termux/files/usr/include/asm/fcntl.h" 2 3 4
# 49 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/seek_constants.h" 1 3 4
# 51 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 3 4
struct __sbuf {
 unsigned char* _base;
 size_t _size;
};
# 49 "/data/data/com.termux/files/usr/include/bits/struct_file.h" 3 4
typedef int64_t _struct_file_off_t;




struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;

 int _flags;
 int _file;




 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 _struct_file_off_t (*_seek)(void *, _struct_file_off_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ext;

 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 _struct_file_off_t _offset;
};
# 54 "/data/data/com.termux/files/usr/include/stdio.h" 2 3 4




typedef off_t fpos_t;
typedef off64_t fpos64_t;

struct __sFILE;
typedef struct __sFILE FILE;
# 75 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
extern FILE __sF[] __attribute__((annotate("obsoleted_in=" "23")));
# 109 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
void clearerr(FILE* __fp);
int fclose(FILE* __fp);
int feof(FILE* __fp);
int ferror(FILE* __fp);
int fflush(FILE* __fp);
int fgetc(FILE* __fp);
char* fgets(char* __buf, int __size, FILE* __fp);
int fprintf(FILE* __fp , const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
int fputc(int __ch, FILE* __fp);
int fputs(const char* __s, FILE* __fp);
size_t fread(void* __buf, size_t __size, size_t __count, FILE* __fp);
int fscanf(FILE* __fp, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
size_t fwrite(const void* __buf, size_t __size, size_t __count, FILE* __fp);
int getc(FILE* __fp);
int getchar(void);


ssize_t getdelim(char** __line_ptr, size_t* __line_length_ptr, int __delimiter, FILE* __fp) __attribute__((annotate("introduced_in=" "18")));
ssize_t getline(char** __line_ptr, size_t* __line_length_ptr, FILE* __fp) __attribute__((annotate("introduced_in=" "18")));



void perror(const char* __msg);
int printf(const char* __fmt, ...) __attribute__((__format__(printf, 1, 2)));
int putc(int __ch, FILE* __fp);
int putchar(int __ch);
int puts(const char* __s);
int remove(const char* __path);
void rewind(FILE* __fp);
int scanf(const char* __fmt, ...) __attribute__((__format__(scanf, 1, 2)));
void setbuf(FILE* __fp, char* __buf);
int setvbuf(FILE* __fp, char* __buf, int __mode, size_t __size);
int sscanf(const char* __s, const char* __fmt, ...) __attribute__((__format__(scanf, 2, 3)));
int ungetc(int __ch, FILE* __fp);
int vfprintf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
int vprintf(const char* __fp, va_list __args) __attribute__((__format__(printf, 1, 0)));


int dprintf(int __fd, const char* __fmt, ...) __attribute__((__format__(printf, 2, 3))) __attribute__((annotate("introduced_in=" "21")));
int vdprintf(int __fd, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0))) __attribute__((annotate("introduced_in=" "21")));
# 165 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int sprintf(char* __s, const char* __fmt, ...)
    __attribute__((__format__(printf, 2, 3))) ;
int vsprintf(char* __s, const char* __fmt, va_list __args)
    __attribute__((__format__(printf, 2, 0))) ;
char* tmpnam(char* __s)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));

char* tempnam(const char* __dir, const char* __prefix)
    __attribute__((deprecated("tempnam is unsafe, use mkstemp or tmpfile instead")));

int rename(const char* __old_path, const char* __new_path);
int renameat(int __old_dir_fd, const char* __old_path, int __new_dir_fd, const char* __new_path);

int fseek(FILE* __fp, long __offset, int __whence);
long ftell(FILE* __fp);
# 203 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int fgetpos(FILE* __fp, fpos_t* __pos);
int fsetpos(FILE* __fp, const fpos_t* __pos);
int fseeko(FILE* __fp, off_t __offset, int __whence);
off_t ftello(FILE* __fp);
# 235 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
FILE* fopen(const char* __path, const char* __mode);





FILE* freopen(const char* __path, const char* __mode, FILE* __fp);
# 252 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int snprintf(char* __buf, size_t __size, const char* __fmt, ...) __attribute__((__format__(printf, 3, 4)));
int vfscanf(FILE* __fp, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));
int vscanf(const char* __fmt , va_list __args) __attribute__((__format__(scanf, 1, 0)));
int vsnprintf(char* __buf, size_t __size, const char* __fmt, va_list __args) __attribute__((__format__(printf, 3, 0)));
int vsscanf(const char* __s, const char* __fmt, va_list __args) __attribute__((__format__(scanf, 2, 0)));







static __inline__ char* ctermid(char* s) {
 if (s == 0) return (char*) "/dev/tty";
 strcpy(s, "/dev/tty");
 return s;
}

FILE* fdopen(int __fd, const char* __mode);
int fileno(FILE* __fp);
int pclose(FILE* __fp);
FILE* popen(const char* __command, const char* __mode);
void flockfile(FILE* __fp);
int ftrylockfile(FILE* __fp);
void funlockfile(FILE* __fp);
int getc_unlocked(FILE* __fp);
int getchar_unlocked(void);
int putc_unlocked(int __ch, FILE* __fp);
int putchar_unlocked(int __ch);
# 290 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int asprintf(char** __s_ptr, const char* __fmt, ...) __attribute__((__format__(printf, 2, 3)));
char* fgetln(FILE* __fp, size_t* __length_ptr);
int fpurge(FILE* __fp);
void setbuffer(FILE* __fp, char* __buf, int __size);
int setlinebuf(FILE* __fp);
int vasprintf(char** __s_ptr, const char* __fmt, va_list __args) __attribute__((__format__(printf, 2, 0)));
# 337 "/data/data/com.termux/files/usr/include/stdio.h" 3 4
int open(const char*, int, ...);
extern pid_t getpid();
extern int unlink(const char*);
void free(void* p);
uint32_t arc4random(void);
static __inline__ FILE* tmpfile() {
 int p = getpid();
 char* path;
 int i;
 for (i = 0; i < 100; i++) {
  unsigned int r = arc4random();
  if (asprintf(&path, "/data/data/com.termux/files/usr/tmp/tmpfile.%d-%u", p, r) == -1) return ((void*)0);
  int fd = open(path, 00000002 | 00000100 | 00000200 | 0400000, 0600);
  free(path);
  if (fd >= 0) {
   FILE* result = fdopen(fd, "w+");
   unlink(path);
   return result;
  }
 }
 return ((void*)0);
}
# 5 "./headers.h" 2
# 1 "/data/data/com.termux/files/usr/include/stdlib.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/alloca.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/wait.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/bits/wait.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/wait.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/bits/wait.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/malloc.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/malloc.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/malloc.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/malloc.h" 3 4
void* malloc(size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(1))) __attribute__((__warn_unused_result__));
void* calloc(size_t __item_count, size_t __item_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2))) __attribute__((__warn_unused_result__));
void* realloc(void* __ptr, size_t __byte_count) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
void free(void* __ptr);

void* memalign(size_t __alignment, size_t __byte_count) __attribute__((__malloc__)) __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));


size_t malloc_usable_size(const void* __ptr) __attribute__((annotate("introduced_in=" "17")));





struct mallinfo {
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};


struct mallinfo mallinfo(void);
# 35 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 45 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
__attribute__((__noreturn__)) void abort(void);
__attribute__((__noreturn__)) void exit(int __status);

__attribute__((__noreturn__)) void _Exit(int __status) __attribute__((annotate("introduced_in=" "21")));




int atexit(void (*__fn)(void));



int at_quick_exit(void (*__fn)(void)) __attribute__((annotate("introduced_in=" "21")));
void quick_exit(int __status) __attribute__((__noreturn__)) __attribute__((annotate("introduced_in=" "21")));



char* getenv(const char* __name);
int putenv(char* __assignment);
int setenv(const char* __name, const char* __value, int __overwrite);
int unsetenv(const char* __name);
int clearenv(void);

char* mkdtemp(char* __template);
char* mktemp(char* __template) __attribute__((deprecated("mktemp is unsafe, use mkstemp or tmpfile instead")));
# 81 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
int mkstemp64(char* __template) __attribute__((annotate("introduced_in=" "21")));


int mkstemp(char* __template);





int mkstemps(char* __template, int __flags);

long strtol(const char* __s, char** __end_ptr, int __base);
long long strtoll(const char* __s, char** __end_ptr, int __base);
unsigned long strtoul(const char* __s, char** __end_ptr, int __base);
unsigned long long strtoull(const char* __s, char** __end_ptr, int __base);



int posix_memalign(void** __memptr, size_t __alignment, size_t __size) __attribute__((annotate("introduced_in=" "17")));
# 109 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
double strtod(const char* __s, char** __end_ptr);
long double strtold(const char* __s, char** __end_ptr) __attribute__((annotate("introduced_in=" "21")));







int atoi(const char* __s) __attribute__((__pure__));
long atol(const char* __s) __attribute__((__pure__));
long long atoll(const char* __s) __attribute__((__pure__));

char* realpath(const char* __path, char* __resolved);
int system(const char* __command);

void* bsearch(const void* __key, const void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

void qsort(void* __base, size_t __nmemb, size_t __size, int (*__comparator)(const void* __lhs, const void* __rhs));

uint32_t arc4random(void);
uint32_t arc4random_uniform(uint32_t __upper_bound);
void arc4random_buf(void* __buf, size_t __n);





int rand_r(unsigned int* __seed_ptr) __attribute__((annotate("introduced_in=" "21")));



double drand48(void);
double erand48(unsigned short __xsubi[3]);
long jrand48(unsigned short __xsubi[3]);





long lrand48(void);
long mrand48(void);
long nrand48(unsigned short __xsubi[3]);
unsigned short* seed48(unsigned short __seed16v[3]);
void srand48(long __seed);



char* initstate(unsigned int __seed, char* __state, size_t __n) __attribute__((annotate("introduced_in=" "21")));
char* setstate(char* __state) __attribute__((annotate("introduced_in=" "21")));



int getpt(void);


int posix_openpt(int __flags) __attribute__((annotate("introduced_in=" "21")));


char* ptsname(int __fd);
int ptsname_r(int __fd, char* __buf, size_t __n);
int unlockpt(int __fd);







typedef struct {
  int quot;
  int rem;
} div_t;

div_t div(int __numerator, int __denominator) __attribute__((__const__));

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

ldiv_t ldiv(long __numerator, long __denominator) __attribute__((__const__));

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

lldiv_t lldiv(long long __numerator, long long __denominator) __attribute__((__const__));




const char* getprogname(void) __attribute__((annotate("introduced_in=" "21")));
void setprogname(const char* __name) __attribute__((annotate("introduced_in=" "21")));



int mblen(const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "26"))) __attribute__((annotate("versioner_no_guard")));
size_t mbstowcs(wchar_t* __dst, const char* __src, size_t __n);
int mbtowc(wchar_t* __wc_ptr, const char* __s, size_t __n) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));
int wctomb(char* __dst, wchar_t __wc) __attribute__((annotate("introduced_in=" "21"))) __attribute__((annotate("versioner_no_guard")));

size_t wcstombs(char* __dst, const wchar_t* __src, size_t __n);
# 230 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
int abs(int __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));
long labs(long __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));
long long llabs(long long __x) __attribute__((__const__)) __attribute__((annotate("introduced_in=" "19")));





float strtof(const char* __s, char** __end_ptr) __attribute__((annotate("introduced_in=" "21")));
double atof(const char* __s) __attribute__((__pure__)) __attribute__((annotate("introduced_in=" "21")));
int rand(void) __attribute__((annotate("introduced_in=" "21")));
void srand(unsigned int __seed) __attribute__((annotate("introduced_in=" "21")));
long random(void) __attribute__((annotate("introduced_in=" "21")));
void srandom(unsigned int __seed) __attribute__((annotate("introduced_in=" "21")));
int grantpt(int __fd) __attribute__((annotate("introduced_in=" "21")));

long long strtoll_l(const char* __s, char** __end_ptr, int __base, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
unsigned long long strtoull_l(const char* __s, char** __end_ptr, int __base, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
long double strtold_l(const char* __s, char** __end_ptr, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
# 263 "/data/data/com.termux/files/usr/include/stdlib.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 1 3 4
# 90 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/stdlib.h" 1 3 4
# 91 "/data/data/com.termux/files/usr/include/android/legacy_stdlib_inlines.h" 2 3 4




static __inline double strtod_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtod(__s, __end_ptr);
}

static __inline float strtof_l(const char* __s, char** __end_ptr, locale_t __l) {
  return strtof(__s, __end_ptr);
}

static __inline long strtol_l(const char* __s, char** __end_ptr, int __base, locale_t __l) {
  return strtol(__s, __end_ptr, __base);
}
# 264 "/data/data/com.termux/files/usr/include/stdlib.h" 2 3 4
# 6 "./headers.h" 2

# 1 "/data/data/com.termux/files/usr/include/unistd.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/sys/select.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/time.h" 1 3 4
# 24 "/data/data/com.termux/files/usr/include/linux/time.h" 3 4
struct timespec {
  __kernel_time_t tv_sec;
  long tv_nsec;
};

struct timeval {
  __kernel_time_t tv_sec;
  __kernel_suseconds_t tv_usec;
};
struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};



struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};
struct itimerval {
  struct timeval it_interval;
  struct timeval it_value;
};
struct __kernel_old_timeval {
  __kernel_long_t tv_sec;
  __kernel_long_t tv_usec;
};
# 36 "/data/data/com.termux/files/usr/include/sys/select.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/signal.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/sigcontext.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm/sigcontext.h" 3 4
struct sigcontext {
  __u64 fault_address;
  __u64 regs[31];
  __u64 sp;
  __u64 pc;
  __u64 pstate;
  __u8 __reserved[4096] __attribute__((__aligned__(16)));
};
struct _aarch64_ctx {
  __u32 magic;
  __u32 size;
};

struct fpsimd_context {
  struct _aarch64_ctx head;
  __u32 fpsr;
  __u32 fpcr;
  __uint128_t vregs[32];
};

struct esr_context {
  struct _aarch64_ctx head;
  __u64 esr;
};

struct extra_context {
  struct _aarch64_ctx head;
  __u64 datap;
  __u32 size;
  __u32 __reserved[3];
};

struct sve_context {
  struct _aarch64_ctx head;
  __u16 vl;
  __u16 __reserved[3];
};
# 36 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/limits.h" 1 3 4
# 37 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/limits.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/float.h" 1 3 4
# 42 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/linux/limits.h" 1 3 4
# 44 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4
# 140 "/data/data/com.termux/files/usr/include/limits.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/posix_limits.h" 1 3 4
# 141 "/data/data/com.termux/files/usr/include/limits.h" 2 3 4
# 38 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/limits.h" 2 3 4
# 33 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 2 3 4
# 42 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/signal.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/linux/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/signal.h" 1 3 4
# 24 "/data/data/com.termux/files/usr/include/asm/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 1 3 4
# 77 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 3 4
typedef struct {
  unsigned long sig[(64 / 64)];
} sigset_t;
typedef unsigned long old_sigset_t;

# 1 "/data/data/com.termux/files/usr/include/asm-generic/signal-defs.h" 1 3 4
# 32 "/data/data/com.termux/files/usr/include/asm-generic/signal-defs.h" 3 4
typedef void __signalfn_t(int);
typedef __signalfn_t * __sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t * __sigrestore_t;
# 82 "/data/data/com.termux/files/usr/include/asm-generic/signal.h" 2 3 4



struct __kernel_sigaction {
  __sighandler_t sa_handler;
  unsigned long sa_flags;

  __sigrestore_t sa_restorer;

  sigset_t sa_mask;
};
typedef struct sigaltstack {
  void * ss_sp;
  int ss_flags;
  size_t ss_size;
} stack_t;
# 25 "/data/data/com.termux/files/usr/include/asm/signal.h" 2 3 4
# 22 "/data/data/com.termux/files/usr/include/linux/signal.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/siginfo.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/asm/siginfo.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 1 3 4
# 23 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef union sigval {
  int sival_int;
  void * sival_ptr;
} sigval_t;
# 43 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef struct siginfo {
  int si_signo;

  int si_errno;
  int si_code;




  union {
    int _pad[((128 - (4 * sizeof(int))) / sizeof(int))];
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
    } _kill;
    struct {
      __kernel_timer_t _tid;
      int _overrun;
      sigval_t _sigval;
      int _sys_private;
    } _timer;
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      sigval_t _sigval;
    } _rt;
    struct {
      __kernel_pid_t _pid;
      __kernel_uid32_t _uid;
      int _status;
      __kernel_clock_t _utime;
      __kernel_clock_t _stime;
    } _sigchld;
    struct {
      void * _addr;
# 87 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
      union {
        short _addr_lsb;
        struct {
          char _dummy_bnd[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
          void * _lower;
          void * _upper;
        } _addr_bnd;
        struct {
          char _dummy_pkey[(__alignof__(void *) < sizeof(short) ? sizeof(short) : __alignof__(void *))];
          __u32 _pkey;
        } _addr_pkey;
      };
    } _sigfault;
    struct {
      long _band;
      int _fd;
    } _sigpoll;
    struct {
      void * _call_addr;
      int _syscall;
      unsigned int _arch;
    } _sigsys;
  } _sifields;
} siginfo_t;
# 223 "/data/data/com.termux/files/usr/include/asm-generic/siginfo.h" 3 4
typedef struct sigevent {
  sigval_t sigev_value;
  int sigev_signo;
  int sigev_notify;
  union {
    int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
    int _tid;
    struct {
      void(* _function) (sigval_t);
      void * _attribute;
    } _sigev_thread;
  } _sigev_un;
} sigevent_t;
# 23 "/data/data/com.termux/files/usr/include/asm/siginfo.h" 2 3 4
# 23 "/data/data/com.termux/files/usr/include/linux/signal.h" 2 3 4
# 43 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 2 3 4
# 54 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
typedef int sig_atomic_t;

typedef __sighandler_t sig_t;
typedef __sighandler_t sighandler_t;





typedef sigset_t sigset64_t;
# 79 "/data/data/com.termux/files/usr/include/bits/signal_types.h" 3 4
struct sigaction { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
struct sigaction64 { int sa_flags; union { sighandler_t sa_handler; void (*sa_sigaction)(int, struct siginfo*, void*); }; sigset_t sa_mask; void (*sa_restorer)(void); };
# 38 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/timespec.h" 1 3 4
# 39 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/signal.h" 1 3 4
# 35 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/sys/user.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/user.h" 3 4
# 1 "/data/data/com.termux/files/usr/lib/clang/7.0.0/include/stddef.h" 1 3 4
# 34 "/data/data/com.termux/files/usr/include/sys/user.h" 2 3 4
# 240 "/data/data/com.termux/files/usr/include/sys/user.h" 3 4
struct user_regs_struct {
  uint64_t regs[31];
  uint64_t sp;
  uint64_t pc;
  uint64_t pstate;
};
struct user_fpsimd_struct {
  __uint128_t vregs[32];
  uint32_t fpsr;
  uint32_t fpcr;
};
# 36 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 2 3 4
# 106 "/data/data/com.termux/files/usr/include/sys/ucontext.h" 3 4
typedef unsigned long greg_t;
typedef greg_t gregset_t[34];
typedef struct user_fpsimd_struct fpregset_t;


typedef struct sigcontext mcontext_t;

typedef struct ucontext {
  unsigned long uc_flags;
  struct ucontext *uc_link;
  stack_t uc_stack;
  union {
    sigset_t uc_sigmask;
    sigset64_t uc_sigmask64;
  };

  char __padding[128 - sizeof(sigset_t)];
  mcontext_t uc_mcontext;
} ucontext_t;
# 42 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 56 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int __libc_current_sigrtmin(void) __attribute__((annotate("introduced_in=" "21")));
int __libc_current_sigrtmax(void) __attribute__((annotate("introduced_in=" "21")));



extern const char* const sys_siglist[(64 + 1)];
extern const char* const sys_signame[(64 + 1)];



int sigaction(int __signal, const struct sigaction* __new_action, struct sigaction* __old_action);






int siginterrupt(int __signal, int __flag);


sighandler_t signal(int __signal, sighandler_t __handler) __attribute__((annotate("introduced_in=" "21")));
int sigaddset(sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));





int sigdelset(sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));





int sigemptyset(sigset_t* __set) __attribute__((annotate("introduced_in=" "21")));





int sigfillset(sigset_t* __set) __attribute__((annotate("introduced_in=" "21")));





int sigismember(const sigset_t* __set, int __signal) __attribute__((annotate("introduced_in=" "21")));
# 111 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int sigpending(sigset_t* __set);





int sigprocmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);





int sigsuspend(const sigset_t* __mask);





int sigwait(const sigset_t* __set, int* __signal);
# 153 "/data/data/com.termux/files/usr/include/signal.h" 3 4
int raise(int __signal);
int kill(pid_t __pid, int __signal);
int killpg(int __pgrp, int __signal);


int tgkill(int __tgid, int __tid, int __signal) __attribute__((annotate("introduced_in_32=" "16")));



int sigaltstack(const stack_t* __new_signal_stack, stack_t* __old_signal_stack);



void psiginfo(const siginfo_t* __info, const char* __msg) __attribute__((annotate("introduced_in=" "17")));
void psignal(int __signal, const char* __msg) __attribute__((annotate("introduced_in=" "17")));



int pthread_kill(pthread_t __pthread, int __signal);
int pthread_sigmask(int __how, const sigset_t* __new_set, sigset_t* __old_set);
# 203 "/data/data/com.termux/files/usr/include/signal.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/android/legacy_signal_inlines.h" 1 3 4
# 204 "/data/data/com.termux/files/usr/include/signal.h" 2 3 4
# 37 "/data/data/com.termux/files/usr/include/sys/select.h" 2 3 4



typedef unsigned long fd_mask;




typedef struct {
  fd_mask fds_bits[1024/(8 * sizeof(fd_mask))];
} fd_set;
# 64 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
void __FD_CLR_chk(int, fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
void __FD_SET_chk(int, fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
int __FD_ISSET_chk(int, const fd_set*, size_t) __attribute__((annotate("introduced_in=" "21")));
# 85 "/data/data/com.termux/files/usr/include/sys/select.h" 3 4
int select(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, struct timeval* __timeout);
int pselect(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, const struct timespec* __timeout, const sigset_t* __mask);
int pselect64(int __fd_count, fd_set* __read_fds, fd_set* __write_fds, fd_set* __exception_fds, const struct timespec* __timeout, const sigset64_t* __mask);
# 36 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4

# 1 "/data/data/com.termux/files/usr/include/bits/fcntl.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/fcntl.h" 3 4
int fcntl(int __fd, int __cmd, ...);
# 38 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/getopt.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/getopt.h" 3 4
int getopt(int __argc, char* const __argv[], const char* __options);

extern char* optarg;
extern int optind, opterr, optopt;
# 39 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 1 3 4
# 36 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 3 4
int ioctl(int __fd, int __request, ...);
# 56 "/data/data/com.termux/files/usr/include/bits/ioctl.h" 3 4
int ioctl(int __fd, unsigned __request, ...) __attribute__((overloadable)) __attribute__((enable_if(1, ""))) __asm__("ioctl");
# 40 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 1 "/data/data/com.termux/files/usr/include/bits/lockf.h" 1 3 4
# 41 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4


# 1 "/data/data/com.termux/files/usr/include/bits/sysconf.h" 1 3 4
# 192 "/data/data/com.termux/files/usr/include/bits/sysconf.h" 3 4
long sysconf(int __name);
# 44 "/data/data/com.termux/files/usr/include/unistd.h" 2 3 4
# 77 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
extern char** environ;

__attribute__((__noreturn__)) void _exit(int __status);

pid_t fork(void);
pid_t vfork(void);
pid_t getpid(void);
pid_t gettid(void) __attribute__((__const__));
pid_t getpgid(pid_t __pid);
int setpgid(pid_t __pid, pid_t __pgid);
pid_t getppid(void);
pid_t getpgrp(void);
int setpgrp(void);


pid_t getsid(pid_t __pid) __attribute__((annotate("introduced_in=" "17")));


pid_t setsid(void);

int execv(const char* __path, char* const* __argv);
int execvp(const char* __file, char* const* __argv);


int execvpe(const char* __file, char* const* __argv, char* const* __envp) __attribute__((annotate("introduced_in=" "21")));


int execve(const char* __file, char* const* __argv, char* const* __envp);
int execl(const char* __path, const char* __arg0, ...) __attribute__((__sentinel__));
int execlp(const char* __file, const char* __arg0, ...) __attribute__((__sentinel__));
int execle(const char* __path, const char* __arg0, ... )
    __attribute__((__sentinel__(1)));






int nice(int __incr);

int setuid(uid_t __uid);
uid_t getuid(void);
int seteuid(uid_t __uid);
uid_t geteuid(void);
int setgid(gid_t __gid);
gid_t getgid(void);
int setegid(gid_t __gid);
gid_t getegid(void);
int getgroups(int __size, gid_t* __list);
int setgroups(size_t __size, const gid_t* __list);
int setreuid(uid_t __ruid, uid_t __euid);
int setregid(gid_t __rgid, gid_t __egid);
int setresuid(uid_t __ruid, uid_t __euid, uid_t __suid);
int setresgid(gid_t __rgid, gid_t __egid, gid_t __sgid);
int getresuid(uid_t* __ruid, uid_t* __euid, uid_t* __suid);
int getresgid(gid_t* __rgid, gid_t* __egid, gid_t* __sgid);
char* getlogin(void);






long fpathconf(int __fd, int __name);
long pathconf(const char* __path, int __name);

int access(const char* __path, int __mode);


int faccessat(int __dirfd, const char* __path, int __mode, int __flags) __attribute__((annotate("introduced_in=" "16")));


int link(const char* __old_path, const char* __new_path);


int linkat(int __old_dir_fd, const char* __old_path, int __new_dir_fd, const char* __new_path, int __flags) __attribute__((annotate("introduced_in=" "21")));


int unlink(const char* __path);
int unlinkat(int __dirfd, const char* __path, int __flags);
int chdir(const char* __path);
int fchdir(int __fd);
int rmdir(const char* __path);
int pipe(int __fds[2]);



int chroot(const char* __path);
int symlink(const char* __old_path, const char* __new_path);


int symlinkat(const char* __old_path, int __new_dir_fd, const char* __new_path) __attribute__((annotate("introduced_in=" "21")));


ssize_t readlink(const char* __path, char* __buf, size_t __buf_size);


ssize_t readlinkat(int __dir_fd, const char* __path, char* __buf, size_t __buf_size)
    __attribute__((annotate("introduced_in=" "21")));


int chown(const char* __path, uid_t __owner, gid_t __group);
int fchown(int __fd, uid_t __owner, gid_t __group);
int fchownat(int __dir_fd, const char* __path, uid_t __owner, gid_t __group, int __flags);
int lchown(const char* __path, uid_t __owner, gid_t __group);
char* getcwd(char* __buf, size_t __size);

void sync(void);
# 193 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
int close(int __fd);

ssize_t read(int __fd, void* __buf, size_t __count);
ssize_t write(int __fd, const void* __buf, size_t __count);

int dup(int __old_fd);
int dup2(int __old_fd, int __new_fd);


int dup3(int __old_fd, int __new_fd, int __flags) __attribute__((annotate("introduced_in=" "21")));


int fsync(int __fd);
int fdatasync(int __fd) __attribute__((annotate("introduced_in=" "9")));
# 222 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
int truncate(const char* __path, off_t __length);
off_t lseek(int __fd, off_t __offset, int __whence);
ssize_t pread(int __fd, void* __buf, size_t __count, off_t __offset);
ssize_t pwrite(int __fd, const void* __buf, size_t __count, off_t __offset);
int ftruncate(int __fd, off_t __length);




int truncate64(const char* __path, off64_t __length) __attribute__((annotate("introduced_in=" "21")));


off64_t lseek64(int __fd, off64_t __offset, int __whence);
ssize_t pread64(int __fd, void* __buf, size_t __count, off64_t __offset) __attribute__((annotate("introduced_in=" "12")));
ssize_t pwrite64(int __fd, const void* __buf, size_t __count, off64_t __offset) __attribute__((annotate("introduced_in=" "12")));
int ftruncate64(int __fd, off64_t __length) __attribute__((annotate("introduced_in=" "12")));

int pause(void);
unsigned int alarm(unsigned int __seconds);
unsigned int sleep(unsigned int __seconds);
int usleep(useconds_t __microseconds);

int gethostname(char* __buf, size_t __buf_size);






int brk(void* __addr);
void* sbrk(ptrdiff_t __increment);

int isatty(int __fd);
char* ttyname(int __fd);
int ttyname_r(int __fd, char* __buf, size_t __buf_size) __attribute__((annotate("introduced_in=" "8")));

int acct(const char* __path);


int getpagesize(void) __attribute__((annotate("introduced_in=" "21")));






long syscall(long __number, ...);

int daemon(int __no_chdir, int __no_close);






pid_t tcgetpgrp(int __fd);
int tcsetpgrp(int __fd, pid_t __pid);
# 311 "/data/data/com.termux/files/usr/include/unistd.h" 3 4
static __inline__ char* getpass(const char* prompt) {

    struct _termios {
        unsigned int c_iflag;
        unsigned int c_oflag;
        unsigned int c_cflag;
        unsigned int c_lflag;
        unsigned char c_line;
        unsigned char c_cc[19 ];
    };

    struct _termios term_old, term_new;
    static char password[513] = { 0 };
    int len = 0, tty_changed = 0;


    while (*prompt) {
        write(1, prompt, 1);
        prompt++;
    }


    if (ioctl(0, 0x5401 , &term_old) == 0) {
        term_new = term_old;
        term_new.c_lflag &= ~0000010;

        if (ioctl(0, 0x5402+0 , &term_new) == 0) {
            tty_changed = 1;
        } else {
            tty_changed = 0;
        }
    }


    char chr;
    while (read(0, &chr, sizeof(char)) > 0) {
        if (chr == '\r' || chr == '\n' || chr == 0) {
            break;
        }

        if (len == sizeof(password)-1) {


            continue;
        } else {
            password[len++] = chr;
        }
    }
    password[len] = 0;


    if (tty_changed) {
        ioctl(0, 0x5402+0 , &term_old);
    }


    write(1, "\n", 1);

    return password;
}
# 8 "./headers.h" 2
# 1 "/data/data/com.termux/files/usr/include/dirent.h" 1 3 4
# 63 "/data/data/com.termux/files/usr/include/dirent.h" 3 4
struct dirent { ino_t d_ino; off64_t d_off; unsigned short d_reclen; unsigned char d_type; char d_name[256]; };
struct dirent64 { ino_t d_ino; off64_t d_off; unsigned short d_reclen; unsigned char d_type; char d_name[256]; };
# 77 "/data/data/com.termux/files/usr/include/dirent.h" 3 4
typedef struct DIR DIR;

DIR* opendir(const char* __path);
DIR* fdopendir(int __dir_fd);
struct dirent* readdir(DIR* __dir);


struct dirent64* readdir64(DIR* __dir) __attribute__((annotate("introduced_in=" "21")));


int readdir_r(DIR* __dir, struct dirent* __entry, struct dirent** __buffer) __attribute__((__deprecated__("readdir_r is deprecated; use readdir instead")));


int readdir64_r(DIR* __dir, struct dirent64* __entry, struct dirent64** __buffer) __attribute__((annotate("introduced_in=" "21"))) __attribute__((__deprecated__("readdir64_r is deprecated; use readdir64 instead")));


int closedir(DIR* __dir);
void rewinddir(DIR* __dir);






int dirfd(DIR* __dir);
int alphasort(const struct dirent** __lhs, const struct dirent** __rhs);


int alphasort64(const struct dirent64** __lhs, const struct dirent64** __rhs) __attribute__((annotate("introduced_in=" "21")));
int scandir64(const char* __path, struct dirent64*** __name_list, int (*__filter)(const struct dirent64*), int (*__comparator)(const struct dirent64**, const struct dirent64**)) __attribute__((annotate("introduced_in=" "21")));


int scandir(const char* __path, struct dirent*** __name_list, int (*__filter)(const struct dirent*), int (*__comparator)(const struct dirent**, const struct dirent**));
# 9 "./headers.h" 2
# 1 "/data/data/com.termux/files/usr/include/errno.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/errno.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/errno.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/linux/errno.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm/errno.h" 1 3 4
# 19 "/data/data/com.termux/files/usr/include/asm/errno.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/errno.h" 1 3 4
# 21 "/data/data/com.termux/files/usr/include/asm-generic/errno.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/asm-generic/errno-base.h" 1 3 4
# 22 "/data/data/com.termux/files/usr/include/asm-generic/errno.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/asm/errno.h" 2 3 4
# 20 "/data/data/com.termux/files/usr/include/linux/errno.h" 2 3 4
# 34 "/data/data/com.termux/files/usr/include/errno.h" 2 3 4








int* __errno(void) __attribute__((__const__));





# 1 "/data/data/com.termux/files/usr/include/android/legacy_errno_inlines.h" 1 3 4
# 48 "/data/data/com.termux/files/usr/include/errno.h" 2 3 4
# 10 "./headers.h" 2

# 1 "/data/data/com.termux/files/usr/include/sys/stat.h" 1 3 4
# 33 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
# 1 "/data/data/com.termux/files/usr/include/linux/stat.h" 1 3 4
# 54 "/data/data/com.termux/files/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
  __s64 tv_sec;
  __u32 tv_nsec;
  __s32 __reserved;
};
struct statx {
  __u32 stx_mask;
  __u32 stx_blksize;
  __u64 stx_attributes;
  __u32 stx_nlink;
  __u32 stx_uid;
  __u32 stx_gid;
  __u16 stx_mode;
  __u16 __spare0[1];
  __u64 stx_ino;
  __u64 stx_size;
  __u64 stx_blocks;
  __u64 stx_attributes_mask;
  struct statx_timestamp stx_atime;
  struct statx_timestamp stx_btime;
  struct statx_timestamp stx_ctime;
  struct statx_timestamp stx_mtime;
  __u32 stx_rdev_major;
  __u32 stx_rdev_minor;
  __u32 stx_dev_major;
  __u32 stx_dev_minor;
  __u64 __spare2[14];
};
# 34 "/data/data/com.termux/files/usr/include/sys/stat.h" 2 3 4
# 117 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; ino_t st_ino; mode_t st_mode; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; dev_t st_rdev; unsigned long __pad1; off_t st_size; int st_blksize; int __pad2; long st_blocks; struct timespec st_atim; struct timespec st_mtim; struct timespec st_ctim; unsigned int __unused4; unsigned int __unused5; };
struct stat64 { dev_t st_dev; ino_t st_ino; mode_t st_mode; nlink_t st_nlink; uid_t st_uid; gid_t st_gid; dev_t st_rdev; unsigned long __pad1; off_t st_size; int st_blksize; int __pad2; long st_blocks; struct timespec st_atim; struct timespec st_mtim; struct timespec st_ctim; unsigned int __unused4; unsigned int __unused5; };
# 154 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
int chmod(const char* __path, mode_t __mode);
int fchmod(int __fd, mode_t __mode);
int mkdir(const char* __path, mode_t __mode);

int fstat(int __fd, struct stat* __buf);
int fstat64(int __fd, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));
int fstatat(int __dir_fd, const char* __path, struct stat* __buf, int __flags);
int fstatat64(int __dir_fd, const char* __path, struct stat64* __buf, int __flags) __attribute__((annotate("introduced_in=" "21")));
int lstat(const char* __path, struct stat* __buf);
int lstat64(const char* __path, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));
int stat(const char* __path, struct stat* __buf);
int stat64(const char* __path, struct stat64* __buf) __attribute__((annotate("introduced_in=" "21")));

int mknod(const char* __path, mode_t __mode, dev_t __dev);
mode_t umask(mode_t __mask);






int mkfifo(const char* __path, mode_t __mode) __attribute__((annotate("introduced_in=" "21")));
# 186 "/data/data/com.termux/files/usr/include/sys/stat.h" 3 4
int fchmodat(int __dir_fd, const char* __path, mode_t __mode, int __flags);
int mkdirat(int __dir_fd, const char* __path, mode_t __mode);


int mknodat(int __dir_fd, const char* __path, mode_t __mode, dev_t __dev) __attribute__((annotate("introduced_in=" "21")));





int utimensat(int __dir_fd, const char* __path, const struct timespec __times[2], int __flags)
  __attribute__((annotate("introduced_in=" "12")));


int futimens(int __dir_fd, const struct timespec __times[2]) __attribute__((annotate("introduced_in=" "19")));






# 1 "/data/data/com.termux/files/usr/include/android/legacy_sys_stat_inlines.h" 1 3 4
# 207 "/data/data/com.termux/files/usr/include/sys/stat.h" 2 3 4
# 12 "./headers.h" 2
# 6 "./parser.h" 2
# 17 "./parser.h"
typedef enum {VAL_INT, VAL_STRING}Type;


struct Field{
 Type type;
 union Field_Type{
  int integer;
  char string[1000];
 }value;
};

struct Field_List{
 struct Field field_array[100];
 int length;
};

struct Record{
 struct Field_List current_field;
 struct Record* next_record;
};

struct Schema_Attributes{
 Type type;
 union Schema_Type{
  char field_name[1000];
 }name;
};

struct Schema{
 struct Schema_Attributes* schema_definition;
 int length;
};


struct String{
 char string[1000];
 int string_length;
};

struct String_List{
 struct String data;
 struct String_List* next_str;
 int length;
};


struct Condition_Operator_Type{
 enum {
  OPERTR,
  INT_TYPE,
  STRING_TYPE,
  BOOL_TYPE
 }type;
 int integer;
 char string[1000];
 char opertr[3];
 _Bool bool_val;
};

union YYSTYPE{
    char string[1000];
    int integer;
    struct Field field;
    struct Field_List* field_list_ptr;

    struct Record* record_ptr;
    struct String_List* string_list_ptr;
    _Bool boolean;
    struct Condition_Operator_Type condtional_operator;
};
# 13 "parser.y" 2
# 1 "./defaults.h" 1





# 1 "/data/data/com.termux/files/usr/include/ctype.h" 1 3 4
# 62 "/data/data/com.termux/files/usr/include/ctype.h" 3 4
extern const char* _ctype_;

int isalnum(int __ch);
int isalpha(int __ch);
int isblank(int __ch);
int iscntrl(int __ch);
int isdigit(int __ch);
int isgraph(int __ch);
int islower(int __ch);
int isprint(int __ch);
int ispunct(int __ch);
int isspace(int __ch);
int isupper(int __ch);
int isxdigit(int __ch);
int tolower(int __ch);
int toupper(int __ch);


int isalnum_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isalpha_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isblank_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int iscntrl_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isdigit_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isgraph_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int islower_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isprint_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int ispunct_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isspace_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isupper_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int isxdigit_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int tolower_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));
int toupper_l(int __ch, locale_t __l) __attribute__((annotate("introduced_in=" "21")));




int isascii(int __ch);
int toascii(int __ch);


int _tolower(int __ch) __attribute__((annotate("introduced_in=" "21")));
int _toupper(int __ch) __attribute__((annotate("introduced_in=" "21")));
# 7 "./defaults.h" 2
# 18 "./defaults.h"
char* masterPath="./master";
char* dataPath="./data";


void strlwr(char* input){
    for(int i=0;i<strlen(input);i++){
        input[i]=tolower(input[i]);
    }
}
void strupr(char* input){
    for(int i=0;i<strlen(input);i++){
        input[i]=toupper(input[i]);
    }
}

void print_list(struct Record* head){
    printf("Now printing\n");
    while(head != ((void*)0)){
        int length = head->current_field.length;
        for(int i=0;i<length;i++){
            switch(head->current_field.field_array[i].type){
                case VAL_INT: printf("%d ",head->current_field.field_array[i].value.integer); break;
                case VAL_STRING: printf("%s ",head->current_field.field_array[i].value.string);break;
                default: printf("Invalid Type\n");
            }
        }
        printf("\n");
        head = head->next_record;
    }
}

void push_back(struct Field_List record, struct Record** head){
 if(*head == ((void*)0)){
        *head = (struct Record*)malloc(sizeof(struct Record));
        (*head)->current_field = record;
        (*head)->next_record = ((void*)0);
        printf("record ka field array first data is %d\n",record.field_array[0].value.integer);
        printf("head ka field array first data is %d\n",(*head)->current_field.field_array[0].value.integer);
    }
    else{
        struct Record* temp = *head;
        while(temp->next_record != ((void*)0)){
            temp = temp->next_record;
        }
        struct Record* temp_record = (struct Record*)malloc(sizeof(struct Record));
        temp_record->current_field = record;
        temp_record->next_record = ((void*)0);
        temp->next_record = temp_record;
    }
    printf("The list after updation\n");
    print_list(*head);
}

_Bool find(struct Record record, struct Record* head){
    while(head != ((void*)0)){
        _Bool flag = 1;



        if(record.current_field.field_array[0].type == head->current_field.field_array[0].type){
            if( record.current_field.field_array[0].type == VAL_STRING){

                if(strcmp(record.current_field.field_array[0].value.string,head->current_field.field_array[0].value.string) != 0){
                    flag = 0;
                }
            }
            else{

                if(record.current_field.field_array[0].value.integer != head->current_field.field_array[0].value.integer){
                    flag = 0;
                }
            }
        }

        if(flag == 1){
            return 1;
        }
        head = head->next_record;
    }
    return 0;
}

void strip(char* input){
    for(int i=0;i<strlen(input);i++){
        if(input[i]=='\n'){
            input[i]='\0';
        }
    }
}
void remove_element(struct Record record);

void remove_index(int index);
# 14 "parser.y" 2

    struct Schema schema;
    struct Record* table_records = ((void*)0);
    struct String_List* string_list_ptr = ((void*)0);
    int yylex();
    extern int yyerror(const char* msg);
    int initFunction(char* tableName);
    void handleError(int isMaster);
    void handle_query_file_error();
# 84 "y.tab.c"
# 119 "y.tab.c"
  enum yytokentype
  {
    GET = 258,
    FROM = 259,
    WHERE = 260,
    INSERT = 261,
    RECORD = 262,
    INTO = 263,
    UPDATE = 264,
    IN = 265,
    SET = 266,
    TO = 267,
    DELETE = 268,
    STMTTERM = 269,
    COMMA = 270,
    LEFT_PARANTHESES = 271,
    RIGHT_PARANTHESES = 272,
    NOT = 273,
    AND = 274,
    OR = 275,
    LESS_THAN = 276,
    LESS_THAN_EQUAL = 277,
    GREATER_THAN = 278,
    GREATER_THAN_EQUAL = 279,
    EQUAL = 280,
    NOT_EQUAL = 281,
    STRING_COMPARISON = 282,
    STRING_LITERAL = 283,
    INTEGER_LITERAL = 284,
    IDENTIFIER = 285
  };
# 183 "y.tab.c"
typedef union YYSTYPE YYSTYPE;





extern YYSTYPE yylval;

int yyparse (void);
# 204 "y.tab.c"
typedef unsigned char yytype_uint8;





typedef signed char yytype_int8;





typedef unsigned short yytype_uint16;





typedef short yytype_int16;
# 370 "y.tab.c"
union yyalloc
{
  yytype_int16 yyss_alloc;
  YYSTYPE yyvs_alloc;
};
# 449 "y.tab.c"
static const yytype_uint8 yytranslate[] =
{
       0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 1, 2, 3, 4,
       5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
      15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30
};
# 538 "y.tab.c"
static const yytype_int8 yypact[] =
{
       2, -2, 10, 20, 23, 31, -41, -41, -41, -41,
       3, 28, 18, 25, 32, -41, -41, 21, 24, 11,
     -22, 34, 11, 11, -41, 3, -41, 35, -41, -41,
      29, 11, 36, 38, -41, -14, -22, 33, -41, -2,
     -14, -14, -14, 19, -7, -41, -41, -41, 22, -1,
      29, -41, 39, -7, 9, -41, -41, -41, -14, -41,
      17, -41, -41, -41, -41, -41, -41, 26, -41, 18,
     -41, -41, -41, -41, -41, -41, 43, -14, -7
};




static const yytype_uint8 yydefact[] =
{
       0, 0, 0, 0, 0, 0, 2, 3, 4, 5,
       0, 0, 0, 0, 0, 1, 13, 0, 12, 0,
       0, 0, 0, 0, 10, 0, 40, 0, 38, 39,
      37, 0, 0, 0, 11, 0, 0, 0, 7, 0,
       0, 0, 0, 28, 6, 15, 18, 19, 0, 0,
      37, 35, 0, 9, 0, 20, 16, 17, 0, 26,
       0, 29, 30, 31, 32, 33, 34, 0, 36, 0,
      21, 14, 24, 23, 27, 22, 0, 0, 8
};


static const yytype_int8 yypgoto[] =
{
     -41, -41, -41, -41, -41, -41, 13, 37, -41, -40,
     -41, -39, -41, -41, -41, -41, -41, -41, -41, -41,
     -16, 4, 27, -13
};


static const yytype_int8 yydefgoto[] =
{
      -1, 5, 6, 7, 8, 9, 11, 17, 18, 44,
      58, 45, 46, 47, 73, 48, 60, 75, 49, 67,
      21, 37, 30, 27
};




static const yytype_int8 yytable[] =
{
      53, 54, 41, 55, 42, 1, 28, 29, 2, 32,
      33, 3, 56, 57, 10, 4, 43, 12, 38, 71,
      61, 62, 63, 64, 65, 66, 70, 13, 56, 57,
      14, 15, 19, 16, 20, 22, 23, 78, 24, 25,
      35, 26, 31, 40, 36, 72, -25, 39, 77, 59,
      51, 69, 52, 76, 68, 74, 0, 0, 0, 0,
       0, 0, 34, 50
};

static const yytype_int8 yycheck[] =
{
      40, 41, 16, 42, 18, 3, 28, 29, 6, 22,
      23, 9, 19, 20, 16, 13, 30, 7, 31, 58,
      21, 22, 23, 24, 25, 26, 17, 7, 19, 20,
       7, 0, 4, 30, 16, 10, 4, 77, 17, 15,
       5, 30, 8, 5, 15, 28, 27, 11, 5, 27,
      17, 12, 39, 69, 50, 29, -1, -1, -1, -1,
      -1, -1, 25, 36
};



static const yytype_uint8 yystos[] =
{
       0, 3, 6, 9, 13, 32, 33, 34, 35, 36,
      16, 37, 7, 7, 7, 0, 30, 38, 39, 4,
      16, 51, 10, 4, 17, 15, 30, 54, 28, 29,
      53, 8, 54, 54, 38, 5, 15, 52, 54, 11,
       5, 16, 18, 30, 40, 42, 43, 44, 46, 49,
      53, 17, 37, 40, 40, 42, 19, 20, 41, 27,
      47, 21, 22, 23, 24, 25, 26, 50, 52, 12,
      17, 42, 28, 45, 29, 48, 51, 5, 40
};


static const yytype_uint8 yyr1[] =
{
       0, 31, 32, 32, 32, 32, 33, 34, 35, 36,
      37, 38, 38, 39, 40, 40, 41, 41, 42, 42,
      42, 42, 43, 44, 45, 46, 47, 48, 49, 50,
      50, 50, 50, 50, 50, 51, 52, 52, 53, 53,
      54
};


static const yytype_uint8 yyr2[] =
{
       0, 2, 1, 1, 1, 1, 6, 5, 10, 6,
       3, 3, 1, 1, 3, 1, 1, 1, 1, 1,
       2, 3, 3, 3, 1, 1, 1, 1, 1, 1,
       1, 1, 1, 1, 1, 4, 3, 0, 1, 1,
       1
};
# 1054 "y.tab.c"
static void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
{
  ((void) (yyvaluep));
  if (!yymsg)
    yymsg = "Deleting";
                                                        ;


  ((void) (yytype));

}





int yychar;


YYSTYPE yylval;

int yynerrs;






int
yyparse (void)
{
    int yystate;

    int yyerrstatus;
# 1098 "y.tab.c"
    yytype_int16 yyssa[200];
    yytype_int16 *yyss;
    yytype_int16 *yyssp;


    YYSTYPE yyvsa[200];
    YYSTYPE *yyvs;
    YYSTYPE *yyvsp;

    long unsigned int yystacksize;

  int yyn;
  int yyresult;

  int yytoken = 0;


  YYSTYPE yyval;
# 1128 "y.tab.c"
  int yylen = 0;

  yyssp = yyss = yyssa;
  yyvsp = yyvs = yyvsa;
  yystacksize = 200;

                                          ;

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = (-2);
  goto yysetstate;





yynewstate:


  yyssp++;





yysetstate:
  *yyssp = (yytype_int16) yystate;

  if (yyss + yystacksize - 1 <= yyssp)



    {

      long unsigned int yysize = (long unsigned int) (yyssp - yyss + 1);
# 1187 "y.tab.c"
      if (10000 <= yystacksize)
        goto yyexhaustedlab;
      yystacksize *= 2;
      if (10000 < yystacksize)
        yystacksize = 10000;

      {
        yytype_int16 *yyss1 = yyss;
        union yyalloc *yyptr =
          (union yyalloc *) malloc (((yystacksize) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) + (sizeof (union yyalloc) - 1)));
        if (! yyptr)
          goto yyexhaustedlab;
        do { long unsigned int yynewbytes; __builtin_memcpy (&yyptr->yyss_alloc, yyss, (yysize) * sizeof (*(yyss))); yyss = &yyptr->yyss_alloc; yynewbytes = yystacksize * sizeof (*yyss) + (sizeof (union yyalloc) - 1); yyptr += yynewbytes / sizeof (*yyptr); } while (0);
        do { long unsigned int yynewbytes; __builtin_memcpy (&yyptr->yyvs_alloc, yyvs, (yysize) * sizeof (*(yyvs))); yyvs = &yyptr->yyvs_alloc; yynewbytes = yystacksize * sizeof (*yyvs) + (sizeof (union yyalloc) - 1); yyptr += yynewbytes / sizeof (*yyptr); } while (0);

        if (yyss1 != yyssa)
          free (yyss1);
      }


      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;


                                               ;

      if (yyss + yystacksize - 1 <= yyssp)
        goto yyabortlab;
    }


                                                      ;

  if (yystate == 15)
    goto yyacceptlab;

  goto yybackup;





yybackup:




  yyn = yypact[yystate];
  if ((!!((yyn) == (-41))))
    goto yydefault;




  if (yychar == (-2))
    {
                                               ;
      yychar = yylex ();
    }

  if (yychar <= 0)
    {
      yychar = yytoken = 0;
                                                    ;
    }
  else
    {
      yytoken = ((unsigned) (yychar) <= 285 ? yytranslate[yychar] : 2);
                                                                  ;
    }



  yyn += yytoken;
  if (yyn < 0 || 63 < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (0)
        goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }



  if (yyerrstatus)
    yyerrstatus--;


                                                         ;


  yychar = (-2);

  yystate = yyn;

  *++yyvsp = yylval;


  goto yynewstate;





yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;





yyreduce:

  yylen = yyr2[yyn];
# 1316 "y.tab.c"
  yyval = yyvsp[1-yylen];


                       ;
  switch (yyn)
    {
        case 2:
# 55 "parser.y"
 { printf("Get query\n");}
# 1326 "y.tab.c"
 break;

  case 3:
# 57 "parser.y"
 { printf("Insert query\n");}
# 1332 "y.tab.c"
 break;

  case 4:
# 59 "parser.y"
 { printf("Update query\n");}
# 1338 "y.tab.c"
 break;

  case 5:
# 61 "parser.y"
 { printf("Delete query\n");}
# 1344 "y.tab.c"
 break;

  case 6:
# 64 "parser.y"
 {



          }
# 1354 "y.tab.c"
 break;

  case 7:
# 71 "parser.y"
 {



                }
# 1364 "y.tab.c"
 break;

  case 8:
# 78 "parser.y"
 {



                }
# 1374 "y.tab.c"
 break;

  case 9:
# 85 "parser.y"
 {

                  struct Record* iter = (yyvsp[0].record_ptr);
                  printf("DELETE KE ANDAR\n");
                  print_list(iter);
                  DIR* dir_handle = opendir((yyvsp[-2].string));
                  struct dirent* dir_entry;
                  int Hack = 2;
                  while((dir_entry=readdir(dir_handle))!=((void*)0)){
                    iter = (yyvsp[0].record_ptr);

                    while(iter!=((void*)0)){
                      printf("the dir handle 2 is %p\n",iter);
                      printf("the type is %d, STRING %d INT %d\n ",iter->current_field.field_array[0].type,VAL_STRING,VAL_INT );
                      switch(iter->current_field.field_array[0].type){
                        case VAL_STRING: if(strcmp(iter->current_field.field_array[0].value.string,dir_entry->d_name)==0){
                                          char path[1000];
                                          sprintf(path,"%s/%s.txt",(yyvsp[-2].string),dir_entry->d_name);
                                          puts("path to deletion");
                                          puts(path);
                                          remove(path);
                                        }
                                        break;
                        case VAL_INT: Hack = 3;

                                        char string_format[1000];
                                        sprintf(string_format,"%d.txt",iter->current_field.field_array[0].value.integer);
                                        printf("string format is %s\n",string_format);
                                        printf("%s is the dir_name\n",dir_entry->d_name);
                                        if(strcmp(string_format,dir_entry->d_name)==0){
                                          char path[1000];
                                          sprintf(path,"%s/%s",(yyvsp[-2].string),dir_entry->d_name);
                                          puts("path to deletion");
                                          puts(path);
                                          remove(path);
                                        }
                                        break;
                      }
                      iter = iter -> next_record;
                    }

                  }
                }
# 1422 "y.tab.c"
 break;

  case 10:
# 130 "parser.y"
 {
                  (yyval.string_list_ptr) = (yyvsp[-1].string_list_ptr) ;
                }
# 1430 "y.tab.c"
 break;

  case 11:
# 135 "parser.y"
 {
                  struct String_List* temp = malloc(sizeof(struct String));
                  strcpy(temp->data.string,(yyvsp[-2].string));
                  temp->data.string_length = strlen((yyvsp[-2].string));
                  (yyvsp[0].string_list_ptr)->length += 1;
                  (yyval.string_list_ptr) ->next_str = temp;

                }
# 1443 "y.tab.c"
 break;

  case 12:
# 144 "parser.y"
 {
                  struct String_List* temp = malloc(sizeof(struct String));
                  strcpy(temp->data.string,(yyvsp[0].string));
                  temp->data.string_length = strlen((yyvsp[0].string));
                  temp->length = 1;
                  (yyval.string_list_ptr) = temp;
                }
# 1455 "y.tab.c"
 break;

  case 13:
# 153 "parser.y"
 { strcpy((yyval.string),(yyvsp[0].string)); }
# 1461 "y.tab.c"
 break;

  case 14:
# 156 "parser.y"
 {
            puts("entered condition list");
            (yyval.record_ptr) = ((void*)0);
            struct Record * iter = (yyvsp[-2].record_ptr);
            if((yyvsp[-1].integer) == 1)
            {
              printf("Inside AND\n");
              while(iter != ((void*)0)){
                if( find(*iter,(yyvsp[0].record_ptr))){
                  push_back(iter->current_field,&(yyval.record_ptr));
                }
                iter = iter->next_record;
              }
            }
            else{
              (yyval.record_ptr) = (yyvsp[-2].record_ptr);
              iter = (yyvsp[0].record_ptr);
              while(iter != ((void*)0)){
                if( !find(*iter,(yyval.record_ptr))){
                  push_back(iter->current_field,&(yyval.record_ptr));
                }
                iter = iter->next_record;
              }
            }
            printf("output after condition\n\n");
            print_list((yyval.record_ptr));
          }
# 1493 "y.tab.c"
 break;

  case 15:
# 184 "parser.y"
 { (yyval.record_ptr) = (yyvsp[0].record_ptr); }
# 1499 "y.tab.c"
 break;

  case 16:
# 187 "parser.y"
 { printf("GAND\n");
                                                                                    (yyval.integer) = 1;
                                                                               }
# 1507 "y.tab.c"
 break;

  case 17:
# 191 "parser.y"
 { printf("GORI\n");
                                                                                  (yyval.integer) = 0;
                                                                                }
# 1515 "y.tab.c"
 break;

  case 18:
# 197 "parser.y"
 { (yyval.record_ptr) = (yyvsp[0].record_ptr); }
# 1521 "y.tab.c"
 break;

  case 19:
# 199 "parser.y"
 { (yyval.record_ptr) = (yyvsp[0].record_ptr); }
# 1527 "y.tab.c"
 break;

  case 20:
# 201 "parser.y"
 {
                  (yyval.record_ptr) = ((void*)0);
                  struct Record * iter = table_records;
                  while(iter != ((void*)0)){
                    if( find(*iter,(yyvsp[0].record_ptr)) ){
                      continue;
                    }
                    else{
                      push_back(iter->current_field,&(yyval.record_ptr));
                    }
                  }
                  iter = iter->next_record;
                }
# 1545 "y.tab.c"
 break;

  case 21:
# 215 "parser.y"
 {
                  (yyval.record_ptr) = (yyvsp[-1].record_ptr);
                }
# 1553 "y.tab.c"
 break;

  case 22:
# 220 "parser.y"
 {
            (yyval.record_ptr)= ((void*)0);
            puts("entered NUMERICAL_CONDITION");
            struct Record* iter = table_records;
            print_list(table_records);
            int pos_of_field = 0;
            for(int i = 0; i < schema.length; i++){
              printf("schema field name %s \n",(yyvsp[-2].string));
              if(strcmp((yyvsp[-2].string),schema.schema_definition[i].name.field_name) == 0){
                pos_of_field = i;
                break;
              }
            }
            printf("table record pointer: %p, first record %d\n",iter,iter->current_field.field_array[pos_of_field].value.integer);
            printf("comparing %d\n",(yyvsp[0].field).value.integer);
            while(iter != ((void*)0)){
              printf("values in iter %d\n",iter->current_field.field_array[pos_of_field].value.integer);

              struct Record* temp = (struct Record*)malloc(sizeof(struct Record));
              temp->current_field = iter->current_field;

              if( strcmp((yyvsp[-1].condtional_operator).opertr,"==") == 0){
                puts("eq");
                printf("$3 value integer is %d\n",(yyvsp[0].field).value.integer);
                if( (yyvsp[0].field).value.integer == iter->current_field.field_array[pos_of_field].value.integer){
                  printf("EQ condition matched\n");
                  push_back(temp->current_field,&(yyval.record_ptr));
                  print_list((yyval.record_ptr));
                }
              }
              if( strcmp((yyvsp[-1].condtional_operator).opertr,"!=") == 0){
                puts("neq");
                if( (yyvsp[0].field).value.integer != iter->current_field.field_array[pos_of_field].value.integer){
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              if( strcmp((yyvsp[-1].condtional_operator).opertr,">") == 0){
                puts("gt");
                if( (yyvsp[0].field).value.integer < iter->current_field.field_array[pos_of_field].value.integer){
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              if( strcmp((yyvsp[-1].condtional_operator).opertr,"<") == 0){
                puts("lt");
                if( (yyvsp[0].field).value.integer > iter->current_field.field_array[pos_of_field].value.integer){
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              if( strcmp((yyvsp[-1].condtional_operator).opertr,">=") == 0){
                puts("geq");
                if( (yyvsp[0].field).value.integer <= iter->current_field.field_array[pos_of_field].value.integer){
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              if( strcmp((yyvsp[-1].condtional_operator).opertr,"<=") == 0){
                puts("leq");
                if( (yyvsp[0].field).value.integer >= iter->current_field.field_array[pos_of_field].value.integer){
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              iter = iter->next_record;
            }
            printf("DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n");
            print_list((yyval.record_ptr));
            printf("DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n");
          }
# 1624 "y.tab.c"
 break;

  case 23:
# 288 "parser.y"
 {
            (yyval.record_ptr) = ((void*)0);
            struct Record* iter = table_records;
            printf("INSIDE STRING COND\n");
            int pos_of_field = 0;
            for(int i = 0; i < schema.length; i++){
              if(strcmp((yyvsp[-2].string),schema.schema_definition[i].name.field_name) == 0){
                pos_of_field = i;
                printf("%d is POS OF FIELD\n",pos_of_field);
                break;
              }
            }

            printf("ITER IS %p\n",iter);
            printf("OP IS %s\n",(yyvsp[-1].condtional_operator).opertr);
            printf("COMPARinG with %s %d\n",(yyvsp[0].field).value.string,strlen((yyvsp[0].field).value.string));
            while(iter != ((void*)0)){
              if( strcmp((yyvsp[-1].condtional_operator).opertr,"=") == 0){
                char temp[1000];
                strcpy(temp,(yyvsp[0].field).value.string);

                printf("Length of the iter string %d\n",strlen(iter->current_field.field_array[pos_of_field].value.string));
                printf("NOW COMPARING %s %d with temp %d\n",iter->current_field.field_array[pos_of_field].value.string,strcmp((yyvsp[0].field).value.string,iter->current_field.field_array[pos_of_field].value.string),strcmp(temp,iter->current_field.field_array[pos_of_field].value.string));
                if(strcmp((yyvsp[0].field).value.string,iter->current_field.field_array[pos_of_field].value.string) == 0){
                  struct Record* temp = (struct Record*)malloc(sizeof(struct Record));
                  temp->current_field = iter->current_field;
                  push_back(temp->current_field,&(yyval.record_ptr));
                }
              }
              iter = iter->next_record;
            }
            printf("DAS STRING CONDITIONES OP IS \n");
            print_list((yyval.record_ptr));
            printf("I AINT GOT NO MONEY\n");
          }
# 1664 "y.tab.c"
 break;

  case 24:
# 325 "parser.y"
 {

            strcpy((yyval.field).value.string , (yyvsp[0].field).value.string);
          }
# 1673 "y.tab.c"
 break;

  case 25:
# 331 "parser.y"
 {

            printf("THE STRING FIELD IS ");
            _Bool flag = 0;
            for(int i = 0; i < schema.length; i++){
              if(strcmp((yyvsp[0].string),schema.schema_definition[i].name.field_name) == 0){
                  flag = 1;
                  break;
                }
              }

            if(flag == 0){

              printf("FIELD NOT FOUND, CHECK QUERY\n");
              goto yyabortlab;
            }
            strcpy((yyval.string),(yyvsp[0].string));
            printf("%s\n",(yyval.string));
            printf("DDDDDDDDDDDDSSSSSSSSSSSSSSEEEEEEEEEEEEE\n");
          }
# 1698 "y.tab.c"
 break;

  case 26:
# 353 "parser.y"
 {
            (yyval.condtional_operator).type = OPERTR;
            strcpy((yyval.condtional_operator).opertr, "=");
            printf("RECEIVED OP %s",(yyval.condtional_operator).opertr);
          }
# 1708 "y.tab.c"
 break;

  case 27:
# 360 "parser.y"
 {
              (yyval.field).type = INT_TYPE;
              (yyval.field).value.integer = (yyvsp[0].field).value.integer;
            }
# 1717 "y.tab.c"
 break;

  case 28:
# 366 "parser.y"
 {
            _Bool flag = 0;
            for(int i = 0; i < schema.length; i++){
              if(strcmp((yyvsp[0].string),schema.schema_definition[i].name.field_name) == 0){
                  flag = 1;
                  break;
                }
              }

            if(flag == 0){

              printf("FIELD NOT FOUND, CHECK QUERY\n");
              goto yyabortlab;
            }
            strcpy((yyval.string),(yyvsp[0].string));
          }
# 1738 "y.tab.c"
 break;

  case 29:
# 384 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, "<");
                        }
# 1747 "y.tab.c"
 break;

  case 30:
# 389 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, "<=");
                        }
# 1756 "y.tab.c"
 break;

  case 31:
# 394 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, ">");
                        }
# 1765 "y.tab.c"
 break;

  case 32:
# 399 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, ">");
                        }
# 1774 "y.tab.c"
 break;

  case 33:
# 404 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, "==");
                        }
# 1783 "y.tab.c"
 break;

  case 34:
# 410 "parser.y"
 {
                          (yyval.condtional_operator).type = OPERTR;
                          strcpy((yyval.condtional_operator).opertr, "!=");
                        }
# 1792 "y.tab.c"
 break;

  case 35:
# 418 "parser.y"
 {
                  if((yyvsp[-1].field_list_ptr)->length == 100){
                    printf("Need more fields in the definition? contact the developer\n");
                    goto yyabortlab;
                  }
                  else{
                    (yyval.field_list_ptr) = (yyvsp[-1].field_list_ptr);
                    (yyval.field_list_ptr) -> field_array[(yyval.field_list_ptr)->length].type = (yyvsp[-2].field).type;
                    switch((yyvsp[-2].field).type){
                      case VAL_INT: (yyval.field_list_ptr)->field_array[(yyval.field_list_ptr)->length].value.integer = (yyvsp[-2].field).value.integer; break;
                      case VAL_STRING: strcpy((yyval.field_list_ptr)->field_array[(yyval.field_list_ptr)->length].value.string, (yyvsp[-2].field).value.string); break;
                      default: printf("This datatype has not been defined\n"); goto yyabortlab;break;
                    }
                    (yyval.field_list_ptr)->length = (yyval.field_list_ptr)->length + 1;
                  }
                }
# 1813 "y.tab.c"
 break;

  case 36:
# 436 "parser.y"
 {
                  if((yyvsp[0].field_list_ptr)->length == 100){
                    printf("Need more fields in the definition? contact the developer\n");
                    goto yyabortlab;
                  }
                  else{
                    (yyval.field_list_ptr) = (yyvsp[0].field_list_ptr);
                    (yyval.field_list_ptr) -> field_array[(yyval.field_list_ptr)->length].type = (yyvsp[-1].field).type;
                    switch((yyvsp[-1].field).type){
                      case VAL_INT:(yyval.field_list_ptr) -> field_array[(yyval.field_list_ptr)->length].value.integer = (yyvsp[-1].field).value.integer; break;
                      case VAL_STRING: strcpy((yyval.field_list_ptr)->field_array[(yyval.field_list_ptr)->length].value.string, (yyvsp[-1].field).value.string); break;
                      default: printf("This datatype has not been defined\n"); goto yyabortlab;break;
                    }
                    (yyval.field_list_ptr)->length = (yyval.field_list_ptr)->length + 1;
                  }
                }
# 1834 "y.tab.c"
 break;

  case 37:
# 453 "parser.y"
 {
                                        (yyval.field_list_ptr) = (struct Field_List*)calloc(1,sizeof(struct Field_List));
                                        (yyval.field_list_ptr)->length = 0;
                                        }
# 1843 "y.tab.c"
 break;

  case 38:
# 459 "parser.y"
 {
                  (yyval.field).type = (yyvsp[0].field).type;
                  switch((yyval.field).type){
                    case VAL_INT : (yyval.field).value.integer = (yyvsp[0].field).value.integer; break;
                    case VAL_STRING: strcpy((yyval.field).value.string,(yyvsp[0].field).value.string); break;
                    default: printf("Illegal type stopping execution\n");goto yyabortlab;
                  }
                }
# 1856 "y.tab.c"
 break;

  case 39:
# 468 "parser.y"
 {
                  (yyval.field).type = (yyvsp[0].field).type;
                  switch((yyval.field).type){
                    case VAL_INT : (yyval.field).value.integer = (yyvsp[0].field).value.integer; break;
                    case VAL_STRING: strcpy((yyval.field).value.string,(yyvsp[0].field).value.string); break;
                    default: printf("Illegal type stopping execution\n");goto yyabortlab;
                  }
                }
# 1869 "y.tab.c"
 break;

  case 40:
# 478 "parser.y"
 {




                  char path_to_schema[1000];
                  strcpy((yyval.string),(yyvsp[0].string));

                  strcpy(path_to_schema,"./master");
                  strcat(path_to_schema,"/");
                  strcat(path_to_schema,(yyval.string));
                  printf("path to schema is %s\n",path_to_schema);
                  FILE* schema_file_handle = fopen(path_to_schema,"r+");

                  if(schema_file_handle==((void*)0)){
                    handle_query_file_error();
                  }
                  printf("Table Schema found!\n");




                  char path_to_table[1000];


                  strcpy(path_to_table,"./data");
                  strcat(path_to_table,"/");
                  strcat(path_to_table,(yyval.string));

                  DIR* table_file_handle = opendir(path_to_table);
                  if(table_file_handle==((void*)0)){
                    handleError(0);
                  }
                  printf("The table is found\n");
                  struct dirent* file = ((void*)0);
                  char* line = ((void*)0);
                  ssize_t read;
                  size_t len;


                  int number_of_attributes = 0;
                  while((read=getline(&line,&len,schema_file_handle)) != -1){
                      number_of_attributes++;
                  }

                  fclose(schema_file_handle);

                  schema.length = number_of_attributes;
                  schema.schema_definition = (struct Schema_Attributes*)malloc(number_of_attributes*sizeof(struct Schema_Attributes));

                  schema_file_handle = fopen(path_to_schema,"r+");


                  int index = 0;
                  while((read = getline(&line,&len,schema_file_handle)) != -1){
                      strip(line);
                      char* token1 = strtok(line,":");
                      strcpy(schema.schema_definition[index].name.field_name,token1);
                      token1 = strtok(((void*)0),":");
                      if(strcmp(token1,"string") == 0){
                          schema.schema_definition[index++].type = VAL_STRING;
                      }
                      else if(strcmp(token1,"int") == 0){
                          schema.schema_definition[index++].type = VAL_INT;
                      }

                  }
                  fclose(schema_file_handle);

                  printf("Number of  Attributes: %d\n",number_of_attributes);
                  for(int i=0;i<number_of_attributes;i++){
                      printf("%s\n",schema.schema_definition[i].name.field_name);
                  }
                  printf("dummy\n");

                  while((file=readdir(table_file_handle))!=((void*)0)){
                    if(file->d_type != 8){
                      continue;
                    }
                    else{
                        struct Field_List record;
                        char filenames[1000];
                        sprintf(filenames,"%s/%s",path_to_table,file->d_name);
                        FILE* ffile = fopen(filenames,"r");
                        read = getline(&line,&len,ffile);
                        strip(line);
                        if(read == -1){

                          handle_query_file_error();
                        }
                        index = 0;
                        printf("%s\n",line);

                        char templine[1000];
                        strcpy(templine,line);
                        char* token = strtok(line,"\t");
                        while(token != ((void*)0)){
                          index++;
                          token = strtok(((void*)0),"\t");
                        }
                        record.length = index;
                        index = 0;
                        token = strtok(templine,"\t");
                        while(token != ((void*)0)){

                            record.field_array[index].type = schema.schema_definition[index].type;
                            if(record.field_array[index].type == VAL_INT){
                                record.field_array[index].value.integer = atoi(token);
                            }
                            else{
                                strcpy(record.field_array[index].value.string,token);
                            }

                            index++;
                            token = strtok(((void*)0),"\t");
                        }
                        push_back(record,&table_records);

                    }
                  }
                  print_list(table_records);
                  strcpy((yyval.string),path_to_table);
                  puts("THE PATH TO THE TABLE IS");
                  puts((yyval.string));
                }
# 1999 "y.tab.c"
 break;
# 2003 "y.tab.c"
 default: break;
    }
# 2016 "y.tab.c"
                                                        ;

  (yyvsp -= (yylen), yyssp -= (yylen));
  yylen = 0;
                              ;

  *++yyvsp = yyval;




  {
    const int yylhs = yyr1[yyn] - 31;
    const int yyi = yypgoto[yylhs] + *yyssp;
    yystate = (0 <= yyi && yyi <= 63 && yycheck[yyi] == *yyssp
               ? yytable[yyi]
               : yydefgoto[yylhs]);
  }

  goto yynewstate;





yyerrlab:


  yytoken = yychar == (-2) ? (-2) : ((unsigned) (yychar) <= 285 ? yytranslate[yychar] : 2);


  if (!yyerrstatus)
    {
      ++yynerrs;

      yyerror ("syntax error");
# 2084 "y.tab.c"
    }



  if (yyerrstatus == 3)
    {



      if (yychar <= 0)
        {

          if (yychar == 0)
            goto yyabortlab;
        }
      else
        {
          yydestruct ("Error: discarding",
                      yytoken, &yylval);
          yychar = (-2);
        }
    }



  goto yyerrlab1;





yyerrorlab:


  if (0)
    goto yyerrorlab;



  (yyvsp -= (yylen), yyssp -= (yylen));
  yylen = 0;
                              ;
  yystate = *yyssp;
  goto yyerrlab1;





yyerrlab1:
  yyerrstatus = 3;

  for (;;)
    {
      yyn = yypact[yystate];
      if (!(!!((yyn) == (-41))))
        {
          yyn += 1;
          if (0 <= yyn && yyn <= 63 && yycheck[yyn] == 1)
            {
              yyn = yytable[yyn];
              if (0 < yyn)
                break;
            }
        }


      if (yyssp == yyss)
        goto yyabortlab;


      yydestruct ("Error: popping",
                  yystos[yystate], yyvsp);
      (yyvsp -= (1), yyssp -= (1));
      yystate = *yyssp;
                                  ;
    }


  *++yyvsp = yylval;




                                                         ;

  yystate = yyn;
  goto yynewstate;





yyacceptlab:
  yyresult = 0;
  goto yyreturn;





yyabortlab:
  yyresult = 1;
  goto yyreturn;






yyexhaustedlab:
  yyerror ("memory exhausted");
  yyresult = 2;







yyreturn:
  if (yychar != (-2))
    {


      yytoken = ((unsigned) (yychar) <= 285 ? yytranslate[yychar] : 2);
      yydestruct ("Cleanup: discarding lookahead",
                  yytoken, &yylval);
    }


  (yyvsp -= (yylen), yyssp -= (yylen));
                              ;
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
                  yystos[*yyssp], yyvsp);
      (yyvsp -= (1), yyssp -= (1));
    }

  if (yyss != yyssa)
    free (yyss);





  return yyresult;
}
# 604 "parser.y"


void handle_query_file_error(){

  switch((*__errno())){
    case 22: printf("The mode provided for opening the file is incorrect\n");break;
    case 12: printf("Out of memory as the memory has hit the memory limit set internally\n");break;
    case 13: printf("Access to the current file is not allowed.Check the permissions set for the file\n");break;
    case 14: printf("The path name is outside your accessible address space\n");break;
    case 2: printf("This file does not exist\n");break;



  }
  exit(1);
}
int yyerror(const char* msg){
  fprintf((&__sF[2])," %s\n",msg);
    return 0;
}



void handleError(int isMaster){

    switch((*__errno())){
    case 13: perror("Permission denied.\n");exit(1);break;

       case 9: perror("fd is not a valid file descriptor opened for reading.\n");exit(1);break;

       case 24: perror("The per-process limit on the number of open file descriptors has been reached.\n");exit(1);break;


       case 23: perror("The system-wide limit on the total number of open files has been reached.\n");exit(1);break;



        case 2: printf("Directory does not exist, or name is an empty string.\n");
                        if(isMaster==1){
                            char c;
                            printf("Do you want to create a new master Directory(y/n)\n");
                            scanf("%c",&c);
                            if(c=='n' || c=='N'){
                                printf("Terminating execution\n");
                                exit(0);
                            }
                            else{

                                mkdir("./master",0777);
                                mkdir("./data",0777);
                                printf(" Make use of the schema and the data helper utilities to fill the schema details and the input files\n");
                            }
                            exit(0);
                            break;
                        }
                        exit(0);


       case 12: perror("Insufficient memory to complete the operation.\n");exit(1);break;


       case 20: perror("name is not a directory.\n");exit(1);break;
    }
}



int initFunction(char *tableName){
    DIR* masterDirectory = opendir("./master");
    if(masterDirectory){
        printf("The master diretory is initialized.\n");
    }
    else{
        handleError(2);
    }
    return 0;
}

int main(int argc, char* argv[]){
    initFunction(argv[0]);
    while(yyparse()==0){

    }
  return 0;
}
